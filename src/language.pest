// file = { SOI ~ NEWLINE* ~ import_section* ~ NEWLINE* ~ ty_struct_definition* ~ NEWLINE* ~ function_definition* ~ EOI }
// file = { SOI ~ NEWLINE* ~ import_section* ~ NEWLINE* ~ EOI }

file = { SOI ~ NEWLINE* ~ statement* ~ NEWLINE* ~ EOI }

/// Visibility

visibility_public = { "public" }
visibility_private = { "private" }
visibility = { visibility_public | visibility_private }

/// Unary Operations

operation_pre_not = { "!" }
expression_not = { operation_pre_not ~ expression_term }

operation_post_increment = { "++" }
expression_increment = { operation_post_increment ~ expression_term }

operation_post_decrement = { "--" }
expression_decrement = { operation_post_decrement ~ expression_term }

/// Binary Operations

operation_and = { "&&" }
operation_or = { "||" }

operation_eq = { "==" }
operation_neq = { "!=" }

operation_geq = { ">=" }
operation_gt = { ">" }
operation_leq = { "<=" }
operation_lt = { "<" }

operation_add = { "+" }
operation_sub = { "-" }
operation_mul = { "*" }
operation_div = { "/" }
operation_pow = { "**" }

operation_binary = _ {
    operation_and | operation_or |
    operation_eq | operation_neq |
    operation_geq | operation_gt | operation_leq | operation_lt |
    operation_add | operation_sub | operation_pow | operation_mul | operation_div
}

// operation_add_assign = { "+=" }
// operation_sub_assign = { "-=" }
// operation_mul_assign = { "*=" }
// operation_div_assign = { "/=" }

/// Types

ty_field = {"field"}
ty_bool = {"bool"}
ty_basic = { ty_field | ty_bool }
ty_basic_or_struct = {ty_basic | ty_struct }
ty_array = {ty_basic ~ ("[" ~ expression ~ "]")+ }
// ty = {ty_array | ty_basic | ty_struct}
ty = {ty_array}
type_list = _{(ty ~ ("," ~ ty)*)?}

/// Structs

ty_struct = { variable }

/// Values

value_boolean = { "true" | "false" }
value_field = @{ "-"? ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
value = { value_boolean | value_field }

/// Variables

// TODO: Include "import" and "conditional"

protected_name = { visibility | value_boolean | "return" }

// keyword = @{ "as" | "in" | "return" | "export" | "false" |
//             "def" | "in" | "return" | "struct" | "true" }

variable = @{ ((!protected_name ~ ASCII_ALPHA) | (protected_name ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }
expression_primitive = { value | variable }

/// Access

from_expression = { expression }
to_expression = { expression }
range = { from_expression? ~ ".." ~ to_expression }
range_or_expression = { range | expression }
access_array = { "[" ~ range_or_expression ~ "]" }
access = { access_array }
expression_postfix = { variable ~ access }

spread = { "..." ~ expression }
spread_or_expression = { spread | expression }

/// Arrays

inline_array_inner = _{(spread_or_expression ~ ("," ~ NEWLINE* ~ spread_or_expression)*)?}
expression_array_inline = { "[" ~ NEWLINE* ~ inline_array_inner ~ NEWLINE* ~ "]"}
expression_array_initializer = { "[" ~ expression ~ ";" ~ value ~ "]" }

/// Conditionals

expression_conditional = { "if" ~ expression ~ "then" ~ expression ~ "else" ~ expression ~ "fi"}
// conditional_if = { "if" }
// conditional_else = { "else" }
//
// conditional_for = { "for" }
//
// conditional = { conditional_if | conditional_else | conditional_for }

/// Expressions

// Consider structs, conditionals, postfix, primary, inline array, array initializer, and unary
expression_term = {
    ("(" ~ expression ~ ")")
    | expression_conditional
    | expression_postfix
    | expression_primitive
    | expression_not
    | expression_increment
    | expression_decrement
    | expression_array_inline
    | expression_array_initializer
}

expression = { expression_term ~ (operation_binary ~ expression_term)* }




expression_tuple = _{ (expression ~ ("," ~ expression)*)? }

/// Statements

statement_assign = { variable ~ "=" ~ expression }
statement_definition = { ty ~ variable ~ "=" ~ expression }
statement_return = { "return" ~ expression_tuple }

statement = { (statement_return | (statement_assign | statement_definition) ~ NEWLINE) ~ NEWLINE* }

/// Utilities

COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)*) }
WHITESPACE = _{ " " | "\t" ~ NEWLINE }

// /// Helpers
//
// helper_range = { expression+ ~ ".." ~ expression+ } // Confirm that '+' is the correct repetition
