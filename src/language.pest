// file = { SOI ~ NEWLINE* ~ import_section* ~ NEWLINE* ~ EOI }
/// Visibility

visibility_public = { "public" }
visibility_private = { "private" }
visibility = { visibility_public | visibility_private }

/// Unary Operations

operation_pre_not = { "!" }
expression_not = { operation_pre_not ~ expression_term }

operation_post_increment = { "++" }
expression_increment = { operation_post_increment ~ expression_term }

operation_post_decrement = { "--" }
expression_decrement = { operation_post_decrement ~ expression_term }

/// Binary Operations

operation_and = { "&&" }
operation_or = { "||" }

operation_eq = { "==" }
operation_neq = { "!=" }

operation_geq = { ">=" }
operation_gt = { ">" }
operation_leq = { "<=" }
operation_lt = { "<" }

operation_add = { "+" }
operation_sub = { "-" }
operation_mul = { "*" }
operation_div = { "/" }
operation_pow = { "**" }

operation_binary = _ {
    operation_and | operation_or |
    operation_eq | operation_neq |
    operation_geq | operation_gt | operation_leq | operation_lt |
    operation_add | operation_sub | operation_pow | operation_mul | operation_div
}

// operation_add_assign = { "+=" }
// operation_sub_assign = { "-=" }
// operation_mul_assign = { "*=" }
// operation_div_assign = { "/=" }

/// Types

ty_field = {"field"}
ty_bool = {"bool"}
ty_basic = { ty_field | ty_bool }
ty_struct = { variable }
ty_basic_or_struct = {ty_basic | ty_struct }
ty_array = {ty_basic ~ ("[" ~ expression ~ "]")+ }
ty = {ty_array | ty_basic | ty_struct}
type_list = _{(ty ~ ("," ~ ty)*)?}

/// Values

value_boolean = { "true" | "false" }
value_field = @{ "-"? ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
value = { value_boolean | value_field }

/// Variables

// TODO: Include "import" and "conditional"

protected_name = { visibility | value_boolean | "return" }

// keyword = @{ "as" | "in" | "return" | "export" | "false" |
//             "def" | "in" | "return" | "struct" | "true" }

variable = @{ ((!protected_name ~ ASCII_ALPHA) | (protected_name ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }
expression_primitive = { value | variable }

/// Access

from_expression = { expression }
to_expression = { expression }
range = { from_expression? ~ ".." ~ to_expression }
range_or_expression = { range | expression }
access_array = { "[" ~ range_or_expression ~ "]" }
access_call = { "(" ~ expression_tuple ~ ")" }
access_member = { "." ~ variable }
access = { access_array | access_call | access_member }
expression_postfix = { variable ~ access+ } // add ++ and -- operators

spread = { "..." ~ expression }
spread_or_expression = { spread | expression }

/// Arrays

inline_array_inner = _{(spread_or_expression ~ ("," ~ NEWLINE* ~ spread_or_expression)*)?}
expression_array_inline = { "[" ~ NEWLINE* ~ inline_array_inner ~ NEWLINE* ~ "]"}
expression_array_initializer = { "[" ~ expression ~ ";" ~ value ~ "]" }

/// Structs

struct_field = { ty ~ variable }
struct_field_list = _{(struct_field ~ (NEWLINE+ ~ struct_field)*)? }
struct_definition = { "struct" ~ variable ~ "{" ~ NEWLINE* ~ struct_field_list ~ NEWLINE* ~ "}" ~ NEWLINE* }

inline_struct_member = { variable ~ ":" ~ expression }
inline_struct_member_list = _{(inline_struct_member ~ ("," ~ NEWLINE* ~ inline_struct_member)*)? ~ ","? }
expression_inline_struct = { variable ~ "{" ~ NEWLINE* ~ inline_struct_member_list ~ NEWLINE* ~ "}" }

/// Conditionals

expression_conditional = { "if" ~ expression ~ "then" ~ expression ~ "else" ~ expression ~ "fi"}

/// Expressions

// Consider structs, conditionals, postfix, primary, inline array, array initializer, and unary
expression_term = {
    ("(" ~ expression ~ ")")
    | expression_inline_struct
    | expression_conditional
    | expression_postfix
    | expression_primitive
    | expression_not
    | expression_increment
    | expression_decrement
    | expression_array_inline
    | expression_array_initializer
}

expression = { expression_term ~ (operation_binary ~ expression_term)* }
expression_tuple = _{ (expression ~ ("," ~ expression)*)? }

/// Statements

statement_assign = { variable ~ "=" ~ expression }
statement_definition = { ty ~ variable ~ "=" ~ expression }
statement_return = { "return" ~ expression_tuple }
statement_iteration = { "for" ~ ty ~ variable ~ "in" ~ expression ~ ".." ~ expression ~ "do" ~ NEWLINE* ~ statement* ~ "endfor"}

statement = {
    (statement_return
    | (statement_iteration
      | statement_assign
      | statement_definition
      ) ~ NEWLINE
    ) ~ NEWLINE*
}

/// Functions

parameter = {visibility? ~ ty ~ variable}
parameter_list = _{(parameter ~ ("," ~ parameter)*)?}
function_definition = {"def" ~ variable ~ "(" ~ parameter_list ~ ")" ~ "->" ~ "(" ~ type_list ~ ")" ~ ":" ~ NEWLINE* ~ statement* }

/// Utilities

COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)*) }
WHITESPACE = _{ " " | "\t" ~ NEWLINE }

/// Abstract Syntax Tree File

file = { SOI ~ NEWLINE* ~ struct_definition* ~ NEWLINE* ~ function_definition* ~ NEWLINE* ~ statement* ~ NEWLINE* ~ EOI }
