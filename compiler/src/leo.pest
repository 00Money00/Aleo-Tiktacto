/// Visibili_type

visibility_public = { "public" }
visibility_private = { "private" }
visibility = { visibility_public | visibility_private }

/// Unary Operations

operation_pre_not = { "!" }
expression_not = { operation_pre_not ~ expression_term }

// expression_increment = { expression+ ~ "++" }
//
// expression_decrement = { expression ~ "--" }

/// Binary Operations

operation_and = { "&&" }
operation_or = { "||" }

operation_eq = { "==" }
operation_neq = { "!=" }

operation_geq = { ">=" }
operation_gt = { ">" }
operation_leq = { "<=" }
operation_lt = { "<" }

operation_add = { "+" }
operation_sub = { "-" }
operation_mul = { "*" }
operation_div = { "/" }
operation_pow = { "**" }

operation_compare = _{
    operation_eq | operation_neq |
    operation_geq | operation_gt |
    operation_leq | operation_lt
}

operation_binary = _{
    operation_compare | operation_and | operation_or |
    operation_add | operation_sub | operation_pow | operation_mul | operation_div
}

assign = { "=" }
operation_add_assign = { "+=" }
operation_sub_assign = { "-=" }
operation_mul_assign = { "*=" }
operation_div_assign = { "/=" }
operation_pow_assign = { "**=" }

operation_assign = {
    assign | operation_add_assign | operation_sub_assign |
    operation_mul_assign | operation_div_assign | operation_pow_assign
}

/// types
type_u8 = {"u8"}
type_u16 = {"u16"}
type_u32 = {"u32"}
type_u64 = {"u64"}
type_u128 = {"u128"}
type_integer = {
    type_u8
    | type_u16
    | type_u32
    | type_u64
    | type_u128
}

type_field = {"fe"}
type_bool = {"bool"}
type_basic = { type_integer | type_field | type_bool }
type_struct = { variable }
type_basic_or_struct = {type_basic | type_struct }
type_array = {type_basic ~ ("[" ~ value ~ "]")+ }
_type = {type_array | type_basic | type_struct}
type_list = _{(_type ~ ("," ~ _type)*)?}

/// Values

value_number = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
value_integer = { value_number ~ type_integer? }
value_field = { value_number ~ type_field }
value_boolean = { "true" | "false" }
value = { value_field | value_boolean | value_integer }

/// Variables

// TODO: Include "import" and "conditional"

protected_name = { visibility | "let" | "for"| "if" | "else" | "as" | "return" }

// keyword = @{ "as" | "in" | "return" | "export" | "false" |
//             "def" | "in" | "return" | "struct" | "true" }

variable = @{ ((!protected_name ~ ASCII_ALPHA) | (protected_name ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }

optionally_typed_variable = { (_type ~ variable) | (variable)}
optionally_typed_variable_tuple = _{ optionally_typed_variable ~ ("," ~ optionally_typed_variable)* }

expression_primitive = { value | variable }

/// Access

from_expression = { expression }
to_expression = { expression }

range = { from_expression? ~ ".." ~ to_expression }
range_or_expression = { range | expression }

access_array = { "[" ~ range_or_expression ~ "]" }
access_call = { "(" ~ expression_tuple ~ ")" }
access_member = { "." ~ variable }
access = { access_array | access_call | access_member }

expression_postfix = { variable ~ access+ }

assignee_access = { access_array | access_member }
assignee = { variable ~ assignee_access* }

spread = { "..." ~ expression }
spread_or_expression = { spread | expression }

/// Arrays

inline_array_inner = _{(spread_or_expression ~ ("," ~ NEWLINE* ~ spread_or_expression)*)?}
expression_array_inline = { "[" ~ NEWLINE* ~ inline_array_inner ~ NEWLINE* ~ "]"}
expression_array_initializer = { "[" ~ spread_or_expression ~ ";" ~ value ~ "]" }

/// Structs

struct_field = { variable ~ ":" ~ _type }
struct_field_list = _{(struct_field ~ (NEWLINE+ ~ struct_field)*)? }
struct_definition = { "struct" ~ variable ~ "{" ~ NEWLINE* ~ struct_field_list ~ NEWLINE* ~ "}" ~ NEWLINE* }

inline_struct_member = { variable ~ ":" ~ expression }
inline_struct_member_list = _{(inline_struct_member ~ ("," ~ NEWLINE* ~ inline_struct_member)*)? ~ ","? }
expression_inline_struct = { variable ~ "{" ~ NEWLINE* ~ inline_struct_member_list ~ NEWLINE* ~ "}" }

/// Conditionals

expression_conditional = { "if" ~ expression ~ "?" ~ expression ~ ":" ~ expression}

/// Expressions

expression_term = {
    ("(" ~ expression ~ ")")
    | expression_inline_struct
    | expression_conditional
    | expression_postfix
    | expression_primitive
    | expression_not
//     | expression_increment
//     | expression_decrement
    | expression_array_inline
    | expression_array_initializer
}

expression = { expression_term ~ (operation_binary ~ expression_term)* }
expression_tuple = _{ (expression ~ ("," ~ expression)*)? }

/// Asserts

assert_eq = {"assert_eq" ~ "(" ~ NEWLINE* ~ expression ~ "," ~ NEWLINE* ~ expression ~ NEWLINE* ~ ")"}
// assert_true = {"assert"}

/// Conditionals
conditional_nested_or_end = { statement_conditional | "{" ~ NEWLINE* ~ statement+ ~ "}"}

/// Statements
statement_return = { "return" ~ expression_tuple }
statement_definition = { "let" ~ variable ~ (":" ~ _type)? ~ "=" ~ expression }
statement_assign = { assignee ~ operation_assign ~ expression }
statement_multiple_assignment = { "let" ~ "(" ~ optionally_typed_variable_tuple ~ ")" ~ "=" ~  variable ~ "(" ~ expression_tuple ~ ")" }
statement_conditional = {"if" ~ "(" ~ expression ~ ")" ~ "{" ~ NEWLINE* ~ statement+ ~ "}" ~ ("else" ~ conditional_nested_or_end)?}
statement_for = { "for" ~ variable ~ "in" ~ expression ~ ".." ~ expression ~ "{" ~ NEWLINE* ~ statement+ ~ "}"}
statement_assert = {
    assert_eq
//     | assert_true |
}
statement_expression = { expression }

statement = {
    (statement_return
    | statement_conditional
    | statement_for
      | (statement_multiple_assignment
      | statement_assert
      | statement_definition
      | statement_assign
      | statement_expression
      ) ~ LINE_END
    ) ~ NEWLINE*
}

/// Functions

parameter = {variable ~ ":" ~ visibility? ~ _type}
parameter_list = _{(parameter ~ ("," ~ parameter)*)?}

function_name = @{ ((!protected_name ~ ASCII_ALPHA) | (protected_name ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }
function_definition = {"function" ~ function_name ~ "(" ~ parameter_list ~ ")" ~ ("->" ~ (_type | "(" ~ type_list ~ ")"))? ~ "{" ~ NEWLINE* ~ statement* ~ NEWLINE* ~ "}" ~ NEWLINE* }

/// Utilities

COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)*) }
WHITESPACE = _{ " " | "\t" ~ (NEWLINE)* }
LINE_END = _{";" ~ NEWLINE*}

/// Imports

import_source = @{(!"\"" ~ ANY)*}
import_symbol = { variable ~ ("as" ~ variable)? }
import_symbol_tuple = _{ import_symbol ~ ("," ~ NEWLINE* ~ import_symbol)* }

import = { "from" ~ "\"" ~ import_source ~ "\"" ~ "import" ~ ("*" | ("{" ~ NEWLINE* ~ import_symbol_tuple ~ NEWLINE* ~ "}")) ~ LINE_END}

/// Program File

file = { SOI ~ NEWLINE* ~ import* ~ NEWLINE* ~ struct_definition* ~ NEWLINE* ~ function_definition* ~ NEWLINE* ~ EOI }
